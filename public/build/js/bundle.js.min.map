{"version":3,"sources":["app.js","hours.js","speakers.js","tags.js"],"names":["removeTildes","string","normalize","replace","document","querySelector","search","category_id","day","category","days","querySelectorAll","daysHidden","hourHidden","searchTerm","e","target","name","value","prevH","classList","remove","Object","values","includes","async","url","location","origin","answ","fetch","events","hoursList","forEach","h","add","hoursTaken","map","hour_id","hoursListArr","Array","from","filter","dataset","hour","addEventListener","selectHour","getAvailablesHours","json","searchEvents","hourId","d","speakersInput","speakersInputHidden","speakers","filteredSpeakers","speakersList","getElementById","selectSpeaker","speaker","prevSpeaker","speaker_id","speakersArr","trim","lastname","id","resetSpeakers","getSpeakers","length","regex","RegExp","toLowerCase","firstChild","removeChild","speakerHTML","createElement","textContent","onclick","appendChild","showSpeakers","tagsInput","tagsContainer","tagsInputHidden","tags","showTags","tag","t","ondblclick","deleteTag","updateInputHidden","toString","keyCode","preventDefault","saveTag","split"],"mappings":"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","file":"bundle.js","sourcesContent":["function removeTildes(string) {\r\n    return string.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\r\n}\r\n","(function () {\r\n    const hours = document.querySelector(\"#hours\");\r\n    if (hours) {\r\n        // Objeto en memoria para comprobar disponibilidad del dia segun la categoria del evento\r\n        let search = {\r\n            category_id: \"\",\r\n            day: \"\",\r\n        };\r\n\r\n        const category = document.querySelector(\"[name='category_id']\");\r\n        const days = document.querySelectorAll(\"[name='day']\");\r\n        const daysHidden = document.querySelector(\"[name='day_id']\");\r\n        const hourHidden = document.querySelector(\"[name='hour_id']\");\r\n\r\n        // Cuando pasamos el callback directamente podemos acceder sin problema al evento en la funccion que mandamos a llamar\r\n        category.addEventListener(\"input\", searchTerm);\r\n        days.forEach((d) => {\r\n            d.addEventListener(\"input\", searchTerm);\r\n        });\r\n\r\n        function searchTerm(e) {\r\n            // le pasamos e.target.name para que de esta forma cuando lo usemos para poder usarlo tanto en el input de dias como de categorias de esta forma toma el atributo del name y lo asocie a la propiedad correspondiente del objeto\r\n            search[e.target.name] = e.target.value;\r\n\r\n            // Reiniciar inputs hidden y selector de horas\r\n            hourHidden.value = \"\";\r\n            daysHidden.value = \"\";\r\n\r\n            // Removes seleccion de la hora previa\r\n            const prevH = document.querySelector(\".hours__hour--selected\");\r\n            // si existe una hora previa removemos la clase\r\n            prevH && prevH.classList.remove(\"hours__hour--selected\");\r\n\r\n            // Si el objeto search tiene alguna de sus propiedades vacías - De esta forma evitamos una consulta innecesaria a la base de datos\r\n            if (Object.values(search).includes(\"\")) {\r\n                return;\r\n            }\r\n            searchEvents();\r\n        }\r\n\r\n        async function searchEvents() {\r\n            // Destructuring del objeto\r\n            const { category_id, day } = search;\r\n            // Creamos url\r\n            const url = `${location.origin}/api/events-time?category_id=${category_id}&day_id=${day}`;\r\n            const answ = await fetch(url);\r\n            const events = await answ.json();\r\n\r\n            getAvailablesHours(events);\r\n        }\r\n\r\n        function getAvailablesHours(events) {\r\n            // Reiniciar horas\r\n            const hoursList = document.querySelectorAll(\".hours__hour\");\r\n            hoursList.forEach((h) => {\r\n                h.classList.add(\"hours__hour--disabled\");\r\n            });\r\n\r\n            // Comprobar eventos ya registrados y quitar horarios no disponibles\r\n            const hoursTaken = events.map((e) => e.hour_id);\r\n            // Convertimos un nodelist en un array, de esta forma podemos utilizar arraymethods\r\n            const hoursListArr = Array.from(hoursList);\r\n\r\n            const availablesHours = hoursListArr.filter(\r\n                // Obtenemos las horas que no esten registradas en la base dedatos para algun evento, de esta forma el usuario solo podrá elegir las horas disponibles\r\n                (h) => !hoursTaken.includes(h.dataset.hour_id)\r\n            );\r\n\r\n            availablesHours.forEach((hour) => {\r\n                hour.classList.remove(\"hours__hour--disabled\");\r\n                hour.addEventListener(\"click\", selectHour);\r\n            });\r\n        }\r\n\r\n        function selectHour(e) {\r\n            // Removes seleccion de la hora previa\r\n            const prevH = document.querySelector(\".hours__hour--selected\");\r\n\r\n            // si existe una hora previa removemos la clase\r\n            prevH && prevH.classList.remove(\"hours__hour--selected\");\r\n\r\n            // Agregamos seleccion visual\r\n            e.target.classList.add(\"hours__hour--selected\");\r\n\r\n            // Leemos el id de la hora\r\n            const hourId = e.target.dataset.hour_id;\r\n            hourHidden.value = hourId;\r\n\r\n            // Llenar el input hidden de dia con el value del input que esté checked, es decir el que está clickeado\r\n            daysHidden.value = document.querySelector(\r\n                \"[name='day']:checked\"\r\n            ).value;\r\n        }\r\n    }\r\n})();\r\n","(function () {\r\n    const speakersInput = document.querySelector(\"#speakers\");\r\n    const speakersInputHidden = document.querySelector(\"[name='speaker_id']\");\r\n    if (speakersInput) {\r\n        // Array para almacenar los ponenetes\r\n        let speakers = [];\r\n        let filteredSpeakers = [];\r\n        const speakersList = document.getElementById(\"speakers-list\");\r\n\r\n        getSpeakers();\r\n\r\n        speakersInput.addEventListener(\"input\", searchSpeakers);\r\n\r\n        async function getSpeakers() {\r\n            const url = `${location.origin}/api/speakers`;\r\n            const answ = await fetch(url);\r\n            const res = await answ.json();\r\n            resetSpeakers(res);\r\n        }\r\n\r\n        function resetSpeakers(speakersArr = []) {\r\n            // Creamos nuevo array de objetos, solo con el nombre y el id de los ponentes\r\n            speakers = speakersArr.map((speaker) => {\r\n                return {\r\n                    name: `${speaker.name.trim()} ${speaker.lastname.trim()}`,\r\n                    id: speaker.id,\r\n                };\r\n            });\r\n        }\r\n\r\n        function searchSpeakers(e) {\r\n            const search = e.target.value;\r\n\r\n            if (search.length > 3) {\r\n                // Regex - forma de buscar un patron en un valor\r\n                // definimos que no importa si la busqueda está en mayusculas o minusculas, esto es util a la hora de querer filtrar busquedas\r\n                const regex = new RegExp(removeTildes(search), \"i\");\r\n\r\n                filteredSpeakers = speakers.filter((speaker) => {\r\n                    // search es un metodo para buscar en un string si no la encuentra retorna -1\r\n                    // si la busqueda retorna distinto de -1\r\n                    if (\r\n                        removeTildes(speaker.name.toLowerCase()).search(\r\n                            regex\r\n                        ) != -1\r\n                    ) {\r\n                        return speaker;\r\n                    }\r\n                });\r\n            } else {\r\n                // Cuando el input esté vacio limpiamos para que no se muestre ningun nombre en pantalla\r\n                filteredSpeakers = [];\r\n                speakersInputHidden.value = \"\";\r\n            }\r\n            showSpeakers();\r\n        }\r\n\r\n        function showSpeakers() {\r\n            while (speakersList.firstChild) {\r\n                // Eliminamos los elementos hijos\r\n                speakersList.removeChild(speakersList.firstChild);\r\n            }\r\n\r\n            if (filteredSpeakers.length > 0) {\r\n                filteredSpeakers.forEach((speaker) => {\r\n                    // Mientras el listado tenga elmentos hijos\r\n                    const speakerHTML = document.createElement(\"LI\");\r\n                    speakerHTML.classList.add(\"speakers-list__speaker\");\r\n                    speakerHTML.textContent = speaker.name;\r\n                    speakerHTML.dataset.speaker_id = speaker.id;\r\n                    speakerHTML.onclick = selectSpeaker;\r\n                    // Add to DOM\r\n                    speakersList.classList.add(\"speakers-list--show\");\r\n                    speakersList.appendChild(speakerHTML);\r\n                });\r\n            }\r\n        }\r\n\r\n        function selectSpeaker(e) {\r\n            const speaker = e.target;\r\n\r\n            // Remover clase previa\r\n            const prevSpeaker = document.querySelector(\r\n                \".speakers-list__speaker--selected\"\r\n            );\r\n            prevSpeaker &&\r\n                prevSpeaker.classList.remove(\r\n                    \"speakers-list__speaker--selected\"\r\n                );\r\n\r\n            speaker.classList.add(\"speakers-list__speaker--selected\");\r\n\r\n            speakersInputHidden.value = e.target.dataset.speaker_id;\r\n        }\r\n    }\r\n})();\r\n","// IIFE - Permiten mantener el scope del codigo en este archivo\r\n(function () {\r\n    const tagsInput = document.querySelector(\"#tags_input\");\r\n    const tagsContainer = document.querySelector(\"#tags\");\r\n    const tagsInputHidden = document.querySelector(\"[name='tags']\");\r\n\r\n    if (tagsInput) {\r\n        let tags = [];\r\n        // Listen for changes\r\n        tagsInput.addEventListener(\"keypress\", function (e) {\r\n            saveTag(e);\r\n        });\r\n\r\n        // Recuperar tags del input hidden\r\n        // Si el input no está vacío\r\n        if (tagsInputHidden.value !== \"\") {\r\n            // Creamos array a partir del string, de los elementos separados por coma (,)\r\n            tags = tagsInputHidden.value.split(\",\");\r\n            showTags();\r\n        }\r\n\r\n        function saveTag(e) {\r\n            // keyCode nos retorna el codigo equivalente a la tecla presionada\r\n            // si presiono una coma\r\n            if (e.keyCode === 44) {\r\n                // Prevenimos la accion por default para que la coma no se agregue al formulario, de esta forma evitamos que al limpiar el input nos quede la coma\r\n                e.preventDefault();\r\n\r\n                // Si el valor del input está vacío o es menor a 1, evitamos que agregue contenido vacío al array de tags\r\n                if (e.target.value.trim() === \"\" || e.target.value < 1) {\r\n                    return;\r\n                }\r\n\r\n                tags = [...tags, e.target.value.trim()];\r\n                // Limpiamos el input para que no se dupliquen los valores en el array\r\n                e.target.value = \"\";\r\n\r\n                showTags();\r\n            }\r\n        }\r\n\r\n        function showTags() {\r\n            // Limpiamos el contenedor, para que al mostrar el array no se dupliquen\r\n            tagsContainer.textContent = \"\";\r\n\r\n            tags.forEach((tag) => {\r\n                const t = document.createElement(\"LI\");\r\n                t.classList.add(\"form__tag\");\r\n                t.textContent = tag;\r\n                tagsContainer.appendChild(t);\r\n\r\n                t.ondblclick = deleteTag;\r\n            });\r\n\r\n            // A la vez que mostramos actualizamos el input hidden\r\n            updateInputHidden();\r\n        }\r\n\r\n        // Agregar o eliminar tags en la base de datos\r\n        function updateInputHidden() {\r\n            // Convertimos el arreglo en un string\r\n            tagsInputHidden.value = tags.toString();\r\n        }\r\n\r\n        // Pasamos el evento para obtener al tag que se le esta haciendo doble click\r\n        function deleteTag(e) {\r\n            // Actualizamos el array de tags, vamos a almacenar todos los elementos que sean distintos al que estamos queriendo eliminar\r\n            tags = tags.filter((t) => t !== e.target.textContent);\r\n            e.target.remove();\r\n            // Actalizamos el input\r\n            updateInputHidden();\r\n        }\r\n    }\r\n})();\r\n"]}